Python - Programação Orientada a Objetos (POO)

0) Para importar uma classe de um arquivo utilizamos:
    0.1) from nome_file import nome_classe

1) Declaração de uma classe em Python
    1.1) (Receita)class Nome_Objeto(bolo a ser feito):
    1.2) pass => Em algum momento, o usuário escreverá código
    1.3) Para trabalhar com as classes, ou seja, sabermos o endereço, devemos fazer a seguinte declaração
        1.3.1) variável = classe()
        1.3.2) Uma classe é uma especificação de um tipo, definindo valores e comportamentos.
        1.3.3) Um objeto é uma instância de uma classe onde podemos definir valores para seus atributos.
        1.3.4) Uma boa analogia é considerar a classe como a receita para a criação de algum prato; por exemplo, um delicioso bolo de cenoura ;-)

2) As características (atributo) de uma classe são denominadas atributos
    2.1) def __init(self) => self é a referência que sabe onde encontrar o endereço do objeto na memória

    2.2) Sempre quisermos acessar uma váriavel, devemos utilizar o 'self'. É como se fosse um ponteiro para apontar a variável que queremos usar.

    2.3) self.__numero = numero => tornando o atributo privado. Esse valor só pode ser acessado por um atributo
OBS: Método serve para acessar um atributo e/ou um objeto

    2.4) Falamos nessa aula sobre a coesão ligado ao princípio de responsabilidade única. Aprendemos que uma classe deve ter apenas uma
    responsabilidade (ou deve ter apenas uma razão para existir). Em outras palavras, ela não deve assumir responsabilidades que não são delas.
        S - Single responsibility principle
        O - Open/closed principle
        L - Liskov substitution principle
        I - Interface segregation principle
        D - Dependency inversion principle

    2.5) @property => Propriedade. Substituir o método getter
        2.5.1) @property
               def nome(self): => colocar a definição da função com o mesmo do atributo
        2.5.2) @nome.setter =. Substitui o método setter
OBS: Para o uso do método setter, utilizamos, a seguinte definição:
        @nome_atributo.setter
        def nome_atributo(self):
            self.__limite = limite

    No arquivo main, declaramos assim:
    conta(objeto).nome_atributo e/ou para definir os valores => conta(objeto).nome_atributo = 1000
    """
    @nome.setter
    def nome(self, novo_nome):
        self.__nome = novo_nome

    Demonstração de declaração no arquivo main.py utilizando o método setter
    filme.nome = "300"
    print(f'O nome do filme é {filme.nome}')
    """
OBS 2: Os atributos DEVEM ser privados

3) Podemos privar um método conforme a seguinte declaração de função => def __nome_metodo()

4) Acessando um método sem a criação de um objeto, através dos métodos estáticos. Ou seja, não precisa do objeto.
    4.1) @staticmethod => def nome_funcao():
OBS: nem sempre é necessário e recomendado criar um método pra acessar uma variável. Basta criarmos um atributo, sem uti-
zar o self, pois criamos um atributo da classe. O atributo faz parte da classe, ou seja, é um atributo estático
que pode ser usado sem ter criado um objeto.

========================================================================================================================
POO Avançado
1) precisamos usar o __class__ para definir que queremos o atributo de classe

2)Herança
    2.1) Encerrar o problema de duplicação de atributos
    2.2) Preciso criar uma classe que tenha todos os atributos que serão usados nas subclasses
    2.3) classe nome (classe mãe)
    2.4) Preciso definir um __init__ nas classes mãe e filhas e passar os seus respectivos parametros
    2.5) Utilizo a função super(). para chamar qualquer método da classe mãe

3) Polimorfismo
    3.1)